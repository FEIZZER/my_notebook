## 数字证书实现
[数字证书名词解释](数字证书名词解释.md)

### 非对称加密

##### 传统对称加密

在传统的对称加密算法中， 通信的双方会采用一个共享的密钥来对数据进行加密和解密。 消息发送方使用密钥对消息进行加密后发送，消息接收方收到信息后使用密钥解密获得信息。 但是在通信开始之前需要先交换加密解密使用的密钥，而交换的过程就会存在泄露的风险。

##### 非对称加密
[RSA加密原理](../base/RSA加密原理.md)
非对称加密算法有两个密钥 ：公开密钥和私有密钥。 公钥和私钥是成对使用，如果用公钥对数据进行加密，只有私钥才能解密。 使用私钥进行加密只能使用公钥进行解密。非对称加密的保密更好，因为它不需要通信加密的私钥。公钥是不需要保密的， 可以对外进行发布。 



但是非对称加密的效率一般比较低， 因此在通信过程中一般会结合对称加密和非对称加密来实现数据的加密传输。 首先通过非对称加密协商加换一个用于对对称加密的共享密钥， 后续在数据传输的过程中使用该密钥来进行加密解密。 SSL/TLS就采用了类似的加密传输机制。 



### 哈希函数

哈希函数是一个具有输入和输出的数学函数 H (X) = Y

- **H**:    哈希函数， 其输入的参数为X， 输出为Y
- **X**： 哈希方法的输入， 可以是任意长度的任意数据
- **Y**： 哈希方法的输出，是一段固定长度的二进制数据， 长度256， 284， 516.......,

用于加密的哈希函数具有一下的特征：

- 无法找到相同输出的输入。 从数学概率上来说书可以找到的，*（输入可以是任意的数据， 输出则是固定长度的数据）*。 但是好的哈希函数可以保证无法在可接受的时间内找到这个解。
- 无法通过输出反推输出。  对于输入值的范围很大的情况来说，这是没有问题的，如果输入值是一个有限的集合，则很容易通过遍历尝试每一个输入值来推断出一个输出对应的输入。在这种情况下，我们可以为输入X加上一个随机值R来隐藏输入值，即 H(R|X)=Y。由于攻击者不知道R的值，因此无法再通过遍历尝试每个输入的方法推断出Y对应的输入。这种做法被称为“加盐”，例如我们在存储密码时就会通过“加盐”的方法来避免彩虹表攻击。

可以认为一段数据的哈希值就是该数据的一个固定长度的特征。



### 数字签名原理

直觉上来说是使用公钥进行加密传输数据然后使用私钥进行解密获取信息。 但是前面说的， 也可以用私钥进行加密然后用公钥进行解密。 私钥的拥有者可以用私钥对一段数据加密， 然后公布**密文 原文 和 公钥**， 任何人都可以使用公钥对密文解密， 再和原文比对。 用这中方式可以确认发布消息中的密钥拥有者。  区块链中广泛使用该方法来验证用户身份。 对原文信息进行加密解密可能非常耗时，所以可以对原文的hash值进行加密后发布。 实现步骤：

1. 消息发布者生成私钥和公钥对， (pkey, skey) = generateKeys(keysize)
2. 消息发布者生成数字签名， signature = encrypt( hash(msg), skey ) ,  发布signature， msg， pkey
3. 消息接收者使用公钥解密信息，  isValid := isEqual(decrypt(pk, signature),hash(message))




### 数字证书
数字签名可以用来证明一个个人或组织拥有一个公钥所对应的私钥。 因此我们可以把公钥看作是一个身份标识， 只要有人可以发布**使用公钥对应私钥加密的数字签名**， 就可以证明他是这个数字身份标识的拥有者。 *在比特币的交易系统中， 就是用公钥作为你的钱包地址。*

#### 数字证书的结构

在使用openssl生成数字证书的时候， 还需要加入一些表明公钥拥有者身份的信息（比如姓名 单位 电子邮件）。将这些信息随着公钥一起发布， 这就是**数字证书**。 

**数字证书**可以理解为包含 **"公钥+个人/组织信息"** 的一段数据， 通过数字签名来证明证书在传输过程中信息没有被篡改。

[RFC5280](https://www.ietf.org/rfc/rfc5280.txt)定义了x.509公钥证书的标准格式



#### 使用openssl创建一个数字证书和私钥

[openssl使用](../lan/linux/openssl使用.md)

1. openssl生成私钥和数字证书

   ```shell
   openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem
   ```

   证书创建时 会要求填入姓名 邮箱 地址等信息

2. openssl解析生成的数字证书

   ```shell
   openssl x509 -in certificate.pem -text
   ```

   ![image-20230412142647326](数字证书原理.assets/image-20230412142647326.png) 

   命令行输出的前半部分是解码后的正式内容，"—–BEGIN CERTIFICATE—–“之后的部分则是采用PEM（Privacy Enhanced Mail）格式进行Base64编码的原始证书文件内容。 其中几个重点的内容：

   - **Issuer**     证书颁发机构
   - **Subject**  证书拥有者
   - **Subject Public Key Info** 证书拥有者的公钥
   - **Signature Algorithm**      加密使用的算法

#### 自签名证书

生成数字证书时 **需要让证书颁发机构（Issuer）的私钥对证书内容(证书拥有者的公钥和身份信息) 进行数字签名**。 如果用来进行数字签名的**密钥**就是证书中公钥对应的**私钥**， 这种采用证书中公钥对应私钥对证书进行数字签名的证书， 被称为自签名证书。 

显然自签名证书没有解决证书使用者和证书拥有者之间的信任问题（自签名证书仅在一些系统的内部使用是可信任的）。 需要一个可被广泛信任的中间机构。



#### 证书机构

在证书体系中引入了证书机构来解决该问题。 我们可以吧证书机构看作是现实世界中的权威机构。 引入证书机构后， 我们使用证书机构的私钥来对数字证书进行签名。

###### 我们认为证书机构是可信的，但是如何保证与我们通信的证书机构是可信的呢？ 

一般在验证证书的时候， 我们需要使用证书机构的公钥。 权威证书机构会为自己颁发一个自签名证书， 这成为证书机构的根证书， 操作系统和浏览器会将这些根证书内置到发布的版本之中， 当验证 用户证书时， 浏览器或操作系统会认为这写根证书时完全可信的， 这样就获得了证书机构的可信的公钥。 *有时， 我们可能想使用一些未被操作系统或浏览器内置的证书机构的根证书， 可以手动导入。 ==谨慎操作==*

![未命名文件 (8)](数字证书原理.assets/未命名文件 (8).png) 

上图的流程可以让接收方client可以确保收到的msg信息确实来自可信的服务端：

1.  sever在本地生成公钥和私钥对(publicKey&secretKey)
2. server端向证书机构发起数字证书申请CSR，*CSR请求中宝包括公钥和sever的身份信息*。
3. 证书机构验证sever身份后， 使用CSR请求中的信息生成数字证书， 并使用自己的CA根证书私钥对该证书签名。
4. sever端用自己的私钥对信息加密， 然后将证书和加密后信息发出。
5. client客户端收到后， 先使用CA根证书中的公钥对服务端发来的用户证书进行验证， 已确认服务端的身份和公钥。
6. 此后可以拿到服务端发来证书的公钥信息， 对加密信息进行解密
7. 这个过程， client客户端可以确定该msg信息为可信任的服务端发送的， 且中间没有被第三方篡改。

#### 证书链

在上面的演示中， 证书机构直接使用根证书的私钥进行证书签名， 实际情况中一般不会这么做。显然根证书的私钥非常重要，如果根证书的私钥泄露会影响所有由他签发的用户证书， 导致非常严重的安全风险。 证书机构一般会签发中间证书（intermediate certificate）, 然后使用中间证书来签发用户证书， 如果中间证书私钥泄露， 影响的范围较小。

因此有三种证书类型， **根证书** **中间证书** **用户证书** 。其中中间证书可以有多个层级， 这样会形成一个链式的证书结构， 称为证书链。 证书链的生成和验证也是一个链式的过程：

**生成**

1. 证书机构生成自签名的根证书
2. 证书机构使用根证书的私钥签发中间证书。
3. 证书机构使用中间证书的私钥签发用户证书。
4. 用户采用用户证书的私钥加密数据。

**验证**

1. 采用中间证书的公钥验证用户证书的签名
2. 采用根证书的公钥验证中间证书的签名
3. 采用用户证书中公钥验证数据中的签名

证书链中证书的关系如下图所示，每一个下级证书中都有其上级证书的DN（Distinguished Name），在进行验证时，每一级都会通过该DN来找到上级证书，并使用上级证书的public Key来验证本机证书的签名，如果中间有多个层级，则会重复该验证过程一直到自签名根证书，由于自签名根证书已经内置在操作系统中，属于系统信任的根证书，到达根证书时就验证完毕，形成了一条从上到下的链状信任关系。

![img](数字证书原理.assets/certificate-chain.png)

#### 交叉认证













