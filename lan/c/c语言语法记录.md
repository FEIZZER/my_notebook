#### 内存对齐

在没有 `#pragma pack` 这个宏声明的情况下， 结构体中的成员变量分布遵循如下的规则：

1. 第一个成员变量的首地址为 0
2. 每个成员变量的的首地址是自身字节数的整数倍
3. 结构体总大小， 必须是成员变量中最大类型的整数倍

```c
// 结构体占据 3字节
struct test
{
  char a;  //1
  char b;  //1
  char c;  //1
};
// 占6字节
struct test
{
  char a;  //1
  short b;  //2
  char c;  //1
};
```

##### 宏声明 #pragma pack() 

在使用了宏声名以后， 1. 每个成员变量的起始地址会变为**min(自身字节数, 你定义的值)**。2. 结构体的总大小也是 **min(最大成员变量字节数, 你指定的值)**的整数倍

*#pragma pack()可以取的值只有 1,2,4,8,16*

```c
// 要求编译器按照1字节来进行对齐, 占了5字节
#pragma  pack(1)
struct test
{
  char a;
  int  b;
};
// 要求按照8字节，但是编译发现可以按照4字节对齐， 长度为8字节
#pragma  pack(8)
struct test
{
  char a;
  int  b;
};
```



#### 位域/位段





#### statistic

c语言中的`statistic` 用于修饰 **局部变量** **全局变量** 和 **函数** ， 用于修改其数据存储的类型。

1. **修饰局部变量**： 在任意一个函数内部定义的变量就是局部变量*(不加statistic)*, 初始值不确定，出函数时自动销毁， 存放于**栈区**。 使用statistic修饰时， 编译器会将其初始化为零， 存储于**静态区**。出函数时不会销毁， 下次进入函数改变量的值依然存在。

2. **全局变量**： 全部变量*（不加statistic）*， 存储于静态区， 对整个过程可见， 其他文件使用关键字 **extern**外部声明后可以直接使用。 

   静态全局变量仅对当前文件可见， 其他文件不可访问。 其他文件可以定义与其同名的全局变量。

3. **函数**： 在函数的返回类型前加上 `statistic` 就是静态函数。 静态函数只能在声明他的文件内使用。

#### extern



#### volatile



#### union





### 









