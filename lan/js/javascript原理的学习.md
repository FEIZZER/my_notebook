#### 浏览器中javascript的事件循环Event Loop

##### 浏览器是多进程且多线程的

![中心主题 (1)](https://gitee.com/feizzer/feizzer_gallery/raw/master/img/202201051934552.png) 

上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个页面（选项卡）崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。下面来分别看下里面每个线程是做什么的。

###### GUI线程

GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。

###### JS引擎线程

这个线程就是负责执行JS的主线程，前面说的"JS是单线程的"就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的while(true)这样长时间的同步代码在真正开发时是绝对不允许的。

###### 定时器线程

setTimeout和setInterval就运行再这个线程中，浏览器的定时器计时并不在js引擎线程中，而是在这个线程中，计时完毕后，就会将添加到事件队列中，等待js引擎线程空闲

###### 事件触发线程

定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。

###### 异步HTTP请求线程

这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。

所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行。这个流程我们多次提到了任务队列，这其实就是Event Loop，下面我们详细来讲解下。

##### Event Loop

所谓Event Loop，就是事件循环，其实就是JS管理事件执行的一个流程，具体的管理办法由他具体的运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。这两个环境的Event Loop还有点区别。

###### **浏览器中js的事件循环**

这个循环实际是通过一个个异步线程的通信协作机制来实现的，为了信息交换，线程之间还有一个公共的数据区，就是我们前面提到的==事件队列==，大致流程如下：

> 主线程（js引擎线程）每次执行时，会看要执行的时同步任务还是异步任务，异步任务则直接执行，异步任务则交给对应的异步线程处理，异步线程会在合适的时候添加到事件队列中，主线程继续执行同步代码。该轮循环同步代码执行完成后会处理事件队列中的任务。

*浏览器事件循环带来的问题：* 每次循环的异步任务都会在同步任务结束后才会执行，如果同步代码出现了死循环，那所有的异步代码就不会再执行了。并且必然的，可能会导致一些setTimeout或setInterval不准。下面这段代码为例setTimeout()是永远不会执行的。

```js
setTimeout(()=>{
    console.log('异步代码执行了')
}, 1000)
while(true){}
```

**引入微任务后再看事件循环**



###### nodejs环境下的事件循环



