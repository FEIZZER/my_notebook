### 常见指令

- **lea** （load effective address）用于加载有效地址。 lea指令主要区别于 mov指令。并且lea指令的操作数只能是寄存器
  - lea是将源操作数地址传递给目的操作数  `lea 4(%ebx), %eax`  将 ebx + 4 的值传给 %eax
  - mov是将源操作数地址指向的值 传递给目的操作数 `mov 4(%ebx), %eax`  将 ebx + 4 地址处的值赋给 %eax
  - 在源操作数简单的情况下 mov完全可以取代lea， 比如 `lea (%ebx), %eax` 就完全对于直接寻址的 `mov %ebx, %eax`
- **push & pop** 这两个指令用于进行压栈和出栈的操作，均只有一个操作数
  - `pushl %eax` 是将先将 %esp-4 ，再将 %eax中的值写入栈
  - `popl %eax` 先将当前 %esp指向的栈空间的值赋给%rax， 再将%esp+4
- **call**  

### AT&T指令风格

- ".s"为汇编语言文件的后缀名
- `.`开头一般为  伪指令， `#` 开头一般为注释
- **寄存器表示**   寄存器前需要加上 `%` 如 `%esp`  。   
- **立即数表示**立即数前需要加上 `$`。  十六进制立即数前加上 `0x`, 如 `movl &0xffff, %ebx`
- **寻址方式**   可以用一个万能公式总节  `disp(base, index, scale) `, 其中 base和index必须是寄存器， disp和scale可以是立即数
  - 立即寻址   `movl $2, %eax`   将立即数2赋值给 %eax
  - 直接寻址  `movl ADDRESS, %eax`   将ADDRES数字代表的地址的值传入 %eax 
  - 间接存志  `movl (%eax), %ebx `   将%eax寄存器存的值作为地址， 将该地址中的值赋给 %ebx
  - 变址寻址(索引寻址)  `movl 0xFFFF0000(, %eax, 4)` 获取 0xFFFF0000 + 4 * %eax 处的值
  - 基址寻址  `movl 4(%eax)`  获取 %eax + 4 处的的值
- **操作位数表达**  b表示1字节   w表示2字节  l 表示4字节   q表示8字节

