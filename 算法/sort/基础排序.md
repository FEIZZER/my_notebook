# 基础排序

![image-20200805205849575](D:\notebook\算法\source\image-20200805205849575.png)

## 冒泡排序$O(n^2)$ 

```
//a[]  n为a[]的长度
//O(n*n)
for(int i=0;i<n;i++)
	for(int j=0;j<n-1;j++)
	{
		if(a[j]>a[j+1])
		{
			int temp=a[j];
			a[j]=a[j+1];
			a[j+1]=temp; 
		}
	}
```

## 选择排序$O(n^2)$ 

```
for(int i=0;i<n;i++)
	{
		int min_index=i;
		for(int j=i+1;j<n;j++)
		{
			if(a[j]<a[min_index])
			min_index=j;
		}
		int tem=a[min_index];
		a[min_index]=a[i];
		a[i]=tem;
	}
```

## 插入排序$O(n^2)$ 

```
void insert_sort(int a[],int len)
{
	int temp;
	for(int i=0;i<len-1;++i)
	{
		int index=i+1; 
		temp=a[index];
		for(int j=i;j>=0;--j)
		{
			if(temp>=a[j])
			a[j+1]=temp;
			else
			{
		       a[j+1]=a[j]; 
		       if(j==0)
		       a[j]=temp;
		   }
		}
	}
} 
```

使用注意

```
insert_sort(a,len);//len数组长度
```



## 快速排序$ O(n\log{n})$ 

```
void qsort(int a[],int left,int right)
{
	int key=a[left];
	int i=left+1;//？？？？？？ 
	int j=right;
	if(left>=right)
	return ;
	while(1)
	{
		while(a[i]<key&&i<right)i++;
		while(a[j]>=key&&j>left)j--;   //改变两个while语句里的><号可以降序排序
		if(j<=i)break;//????
		swap(a[i],a[j]);
	}
	swap(a[left],a[j]);
	qsort(a,left,j-1);
	qsort(a,j+1,right);
 } 
```

使用时注意

```
qsort(a,0,len-1);  //len数组长度
```



## 希尔排序$O(nlog^2n)$ 

暂时不想看



## 归并排序$O(n\log{n})$ 

```
 void mergeSort(int[] arr, int left, int right, int[] temp) {
        if(left < right) {
            int mid = (left + right) / 2; //中间索引
            //向左递归进行分解
            mergeSort(arr, left, mid, temp);
            //向右递归进行分解
            mergeSort(arr, mid + 1, right, temp);
            //合并
            merge(arr, left, mid, right, temp);
        }
    }

    /**
     * 合并的方法
     * @param arr 待排序的原始数组
     * @param left 左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边索引
     * @param temp 做中转的数组
     */
 void merge(int[] arr, int left, int mid, int right, int[] temp) {

        int i = left; // 初始化i, 左边有序序列的初始索引
        int j = mid + 1; //初始化j, 右边有序序列的初始索引
        int t = 0; // 指向temp数组的当前索引

        //(一)
        //先把左右两边(有序)的数据按照规则填充到temp数组
        //直到左右两边的有序序列，有一边处理完毕为止
        while (i <= mid && j <= right) { //继续
            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
            //即将左边的当前元素，填充到temp数组
            //然后 t++, i++
            if(arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t = t + 1;
                i = i + 1;
            } else { //反之,将右边有序序列的当前元素，填充到temp数组
                temp[t] = arr[j];
                t += 1;
                j += 1;
            }
        }

        //(二)
        //把有剩余数据的一边的数据依次全部填充到temp
        while( i <= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[i];
            t += 1;
            i += 1;
        }
        while( j <= right) { //右边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[j];
            t += 1;
            j += 1;
        }

        //(三)
        //将temp数组的元素拷贝到arr
        //注意，并不是每次都拷贝所有，这句话和递归有关，要理解有一定的难度
        //因为这里并不是全部分完之后再合，而是分一点合一点
        t = 0;
        int tempLeft = left; //
        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3
        //最后一次 tempLeft = 0  right = 7
        while(tempLeft <= right) {
            arr[tempLeft] = temp[t];
            t += 1;
            tempLeft += 1;
        }
    }
```

使用注意

```
mergeSort(a,0,len-1,temp);  //len数组长度，temp临时的数组
```

