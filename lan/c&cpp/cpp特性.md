## 面向对象

##### 创建对象的两种方式

C++在创建对象的时候可以采用两种方式：（例如类名为Test）`Test test` 或者 `Test* pTest = new Test()`。

这两种方法都可以实例化一个对象，但是这两种方法有很大的区别，**对象内容所在的内存空间不同**，众所周知，内存的分配方式有三种：

1. **从静态存储区域分配。** 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2. **在栈上创建。** 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。
3. **从堆上分配的。** 程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。

我们可以得出**在不使用new创建对象时，对象的内存空间是在栈中的**，其**作用范围只是在函数内部**，函数执行完成后就会调用析构函数，删除该对象。

而**使用new创建对象是创建在堆中的**，必须要程序员手动的去管理该对象的内存空间。

new创建类对象，使用完后需使用delete删除，跟申请内存类似。所以，new有时候又不太适合，比如在频繁调用场合，使用局部new类对象就不是个好选择，使用全局类对象或一个经过初始化的全局类指针似乎更加高效。

:tired_face:

#### c++的权限管理和继承机制

> (1)需要被外界访问的成员直接设置为public
> (2)只能在当前类中访问的成员设置为private
> (3)只能在当前类和子类中访问的成员设置为protected。







## 其他使用特性

### 左值与右值 （值类别）

> **左值(lvalue, locator, value)** 表示一个 占据了内存中可识别位置*(一个地址，栈或堆)* 的对象。
>
> **右值**   使用排除法来定义 右值就是一个 *不* 表示内存中某个可识别位置的对象的表达式。只存放在寄存器中的临时的值。

#### 从cpp 11开始

cpp 11之前， cpp的左值分类基本遵循c语言的分类。 









### 关键字

##### constexpr 

##### auto

##### typeid *c++11 特性*



##### decltype *c++11 特性*

> decltype可以用于在编译时推导一个表达式(expression)的类型

```cpp
int a = 6;
volatile const int &x = a;
decltype(x) y = a;		// y -> volatile const& 
```

decltype可以推导出表达式的类型, 并且直接用于声明新的变量. 且保留了 **cv限定符** 和 **指针/引用** 属性

decltype类型推导的规则

1.  exp 是函数调用，decltype(exp) 和返回值的类型一致.

2.  exp 是变量 类访问表达式 计算表达式时，decltype(exp) 和 exp 的类型一致.

   1. 但是注意, 如果是赋值表达式, 赋值表达式的类型实际上是**左值引用到被赋值对象的类型**

      



### 模板template

> 模板是cpp支持泛型编程的基础. 模板包括函数模板和类模板. 函数的形参类型或类的内部类型不具体指定(编译器根据使用做类型推导), 用一个虚拟的类型来代替.
>

*`typename` 和 `class`关键字一般通用, 但是只有`typename`可以做为 一个型别 的前置标识符*



#### 模板类型约束



##### SFINAE (Substitution failure is not an error ) 



##### require  *c++20 特性*









### 引用的底层实现 int&



