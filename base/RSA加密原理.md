## RSA加密的原理与流程

#### 过程中用到的数学原理
[[欧拉函数]]
[[欧拉函数#欧拉定理（费马-欧拉定理）]]

模反元素

### 大致流程

##### 第一步，随机取两个不相等的质数，并相乘得到 n

这里我们选择 61和53.相乘得到3233*这两个质数越大，破解难度就越大*。

n的长度决定了密钥的长度， n=3233的二进制表示为 **110010100001**，一共12位，这个密钥就是12位。实际应用场景密钥长度会是1024或2048。

##### 第二步 根据欧拉函数计算 φ(n)

因为n来自两个质数的相乘，所以根据欧拉函数易得 $φ(n) = (p-1)(q-1)，φ(n) = 3120$.

##### 第三步，决定我们公钥关键部分e，在 1~φ(n)之间选择一个整数，要求与 φ(n)互质

我们在1~3120 选择17.

##### 第四步 根据模反元素 决定私钥的关键部分d

e*d mod = 1 根据模反元素可得 d其中一解 d=2753

##### 第五步，n和e封装位公钥，n和d封装为私钥

这里的公钥就是（3233， 17）私钥就是（3233， 2753）。实际应用中，公钥和私钥的数据都采用[ASN.1](http://zh.wikipedia.org/zh-cn/ASN.1)格式表达

##### 第六步 使用公钥加密数据，私钥解密

我们随机取一个数字 m = 20。

公钥加密：$encrypted\_m  = m^e\  mod\ n$ ,计算得到 encrypt_m = 3023

私钥解密： $decrypted\_m =  encrypt\_m^d\ mod \ n$  计算 $3023^{2753}\ mod \ 3233 = 20$ 

##### 为什么rsa能完美还原加密前的数据

证明： $\tag{1}根据欧拉定理有： m^{φ(n)} mod\ n \equiv 1 \ (1), 根据模反元素有： e*d\ mod\ φ(n) \equiv 1$ 

​			$由于 1^k = 1 可得  m^{kφ(n)} mod\ n \equiv 1 \ (2),$  

​			$对式子(2)左右两侧乘m，可得\ m^{kφ(n)+1} mod\ n \equiv m \ (3)$ 

​			$由于\ e*d\ mod\ φ(n) \equiv 1\ ,所以e*d = k*φ(n) +1$ 

​			$此时可将式子(3) 代换成\ m^{e*d} mod\ n \equiv m \ $ 

找到e和d两个值使得 $\ m^{e*d} mod\ n \equiv m \ $ .....

##### rsa算法的安全性

回顾上面的rsa加密流程，一共出现了6个数字   {p, q,  n, φ(n), e, d}。  p和q是最初的两个质数。（e, n）组成公钥。(d, n)组成私钥。其中只有公钥部分是公开的 （e, n）。

###### 是否可以只凭借 e和n就可以计算出私钥d

由于 $e*d\ mod\ φ(n) \equiv 1$ 还需要得出 φ(n)的值

$φ(n)=(p-1)(q-1)$ ,只要获取 p q就可以得到 φ(n).

而n = p*q,要想得到p q，只能对n进行因式分解，如果n被因式分解也意味着rsa加密被破解。可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。目前已经声明的可以破解的最大长度的整数是768个二进制位（232个十进制）。所以我们默认密钥长度1024（二进制）的rsa加密是安全的。



​			









