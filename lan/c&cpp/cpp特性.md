## 面向对象

##### 创建对象的两种方式

C++在创建对象的时候可以采用两种方式：（例如类名为Test）`Test test` 或者 `Test* pTest = new Test()`。

这两种方法都可以实例化一个对象，但是这两种方法有很大的区别，**对象内容所在的内存空间不同**，众所周知，内存的分配方式有三种：

1. **从静态存储区域分配。** 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2. **在栈上创建。** 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。
3. **从堆上分配的。** 程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。

我们可以得出**在不使用new创建对象时，对象的内存空间是在栈中的**，其**作用范围只是在函数内部**，函数执行完成后就会调用析构函数，删除该对象。

而**使用new创建对象是创建在堆中的**，必须要程序员手动的去管理该对象的内存空间。

new创建类对象，使用完后需使用delete删除，跟申请内存类似。所以，new有时候又不太适合，比如在频繁调用场合，使用局部new类对象就不是个好选择，使用全局类对象或一个经过初始化的全局类指针似乎更加高效。

:tired_face:

#### c++的权限管理和继承机制

> (1)需要被外界访问的成员直接设置为public
> (2)只能在当前类中访问的成员设置为private
> (3)只能在当前类和子类中访问的成员设置为protected。







## 其他使用特性

### 左值与右值 （值类别）

> **左值(lvalue, locator, value)** 表示一个 占据了内存中可识别位置*(一个地址，栈或堆)* 的对象。
>
> **右值**   使用排除法来定义 右值就是一个 *不* 表示内存中某个可识别位置的对象的表达式。只存放在寄存器中的临时的值。

#### 从cpp 11开始

cpp 11之前， cpp的左值分类基本遵循c语言的分类,  其中

- **左值**: 一个左值是一个表达式，它具有标识符并且在内存中有地址(存放在栈或者堆中)。左值可以出现在赋值语句的左边或者取地址操作符（&）的操作数中。例如，变量、数组元素、对象成员等都是左值。
- **右值**: 一个右值是一个临时的、不可标识的表达式，它没有地址。右值可以出现在赋值语句的右边或者作为函数返回值。例如，常量、字面量、临时对象等都是右值。

但是注意并不能通过这个值是否存放在内存中来判断是否为左值或右值. 我们可以从函数调用的二进制机器指令的角度去理解:

对于函数返回值类型为**基本类型**的函数, 其返回值可以通过寄存器传递*(即没有将该值存储在内存中, 仅在寄存器中 或 在指令中作为立即数出现)*, 那么该值必然就是右值. 使用 `g++  -S main.cpp`  汇编一下代码可以看到:

 ![image-20240325143613065](./cpp%E7%89%B9%E6%80%A7.assets/image-20240325143613065.png) 

但是如果函数返回值为用户定义的符合类型**user-defined type** *(结构体或cpp类)*.  函数返回时, 不能将数据放在寄存器中传递, 那么只能将其存在栈上. 但是cpp依然将这个值为是右值.

此外cpp还有以下两个特殊的特性, 上面的内容有助于理解下面的第一条特性: 

1. 对于自定义的类型(cpp类),  右值允许其调用自己的成员函数, 在该成员函数中也允许修改其自身. 这也表明了cpp对象的右值实际上存储在内存中的.

   ps: 不管是c还是cpp, 基本类型的右值都是不允许修改的

2. 在cpp中, 右值允许被 const类型的reference. 同时cpp11之前, 右值也只能被const类型的reference引用. 注意这里没有限制用户定义的类型, 因此下面的代码是合法的

   ```cpp
   // void rvalue_test2(int& a){}  error: non-const reference must be lvalue
   void rvalue_test2(const int& a){}
   
   rvalue_test2(a + 1);
   const int& c = a + 1;
   ```

   但是上面说到 右值仅仅是一个临时变量, 表达式结束后会被销毁, 那这里 `&c` 引用值又该引用到哪里去呢?  一般来说，C++ 中的临时变量在表达式结束之后 (full expression) 就被会销毁，但是如果这个临时变量被用来初始化一个引用的话, 这个右值的声明周期就会延长,知道引用被销毁, 以避免产生引用悬空(dangling). 

   但是再等等, 如果该右值存在了栈上还好说, 但是在上面的例子中  `const int& c = a + 1`, 其中  `a+1` 显然只会存在于寄存器, 难道 `&c` 引用到寄存器去吗? 显然是不可能的.  查看g++汇编结果可以看到, 对于 `a + 1` 这样的值, 会先将他从寄存器存到栈上,再做引用.

   ![image-20240325144556191](./cpp%E7%89%B9%E6%80%A7.assets/image-20240325144556191.png) 

实际上上述的这些特性导致了右值和左值均可以被引用所使用, 引起了不少问题. 于是 cpp11开始引入了新的右值引用,进而引出了新的移动语义, 这就使得左值右值的理解变得更加重要.



#### cpp11开始

前面说到const左值引用可以绑定右值和左值,  这使得引用传参时出现某些歧义. 于是乎出现了右值引用

```cpp
void parameter_transfer(Base& base)
{
	std::cout << "lvalue reference" << std::endl;
}
void parameter_transfer(Base&& base)
{
	std::cout << "rvalue reference" << std::endl;
}
int main()
{
	Base base1 = Base();
	// Base& base2 = Base(); error: 左值引用不能绑定左值
	Base&& base3 = Base();
    // Base&& base4 = base1; error: 右值引用不用绑定左值
	parameter_transfer(base1); // lvalue
	parameter_transfer(base3); // lvalue, 右值引用表达式本身是左值
	parameter_transfer(Base());// rvalue
}
```

- 对于右值来说, 理论上是无法进行左引用的
- 对于左值来说, 是可以转化为右值的
- 右值引用类型的表达式, 本身是左值.



##### 纯左值lvalue, 将亡值xvalue, 纯右值prvalue

![img](./cpp%E7%89%B9%E6%80%A7.assets/492369-20151211105645574-1841127867.png) 

- **lvalue**   即我们上面讨论的左值类型

- **prvalue** 即我们上面讨论的右值类型, 事实上在cpp11之前右值和纯右值是等价的, 将亡值的定义由右值引用的引入而产生的.

- **xvalue**   由cpp标准定义的 将亡值(expired value) 是:

  - 返回值为右值引用的 函数调用表达式
  - 转换为右值引用的 转换函数调用表达式.

  到此xvalue的定义要么很抽象, 要么很具体到函数定义.  ==实际上我认为, 将亡值的定义可以拓展为被创建出来并存储在内存中用于初始化赋值操作, 且完成赋值操作后很快消亡的值== 



##### 右值引用和通用引用的区别



##### 引入右值引用后, 对cpp对象拷贝的优化



![image-20240325155448332](./cpp%E7%89%B9%E6%80%A7.assets/image-20240325155448332.png) 



#### 模板的类型推导

##### typeid *c++11 特性*



##### decltype *c++11 特性*

> decltype可以用于在编译时推导一个表达式(expression)的类型

```cpp
int a = 6;
volatile const int &x = a;
decltype(x) y = a;		// y -> volatile const& 
```

decltype可以推导出表达式的类型, 并且直接用于声明新的变量. 且保留了 **cv限定符** 和 **指针/引用** 属性

decltype类型推导的规则

1.  exp 是函数调用，decltype(exp) 和返回值的类型一致.

2.  exp 是变量 类访问表达式 计算表达式时，decltype(exp) 和 exp 的类型一致.

   1. 但是注意, 如果是赋值表达式, 赋值表达式的类型实际上是**左值引用到被赋值对象的类型**

      



### 模板template

> 模板是cpp支持泛型编程的基础. 模板包括函数模板和类模板. 函数的形参类型或类的内部类型不具体指定(编译器根据使用做类型推导), 用一个虚拟的类型来代替.
>

*`typename` 和 `class`关键字一般通用, 但是只有`typename`可以做为 一个型别 的前置标识符*



#### 模板类型约束



##### SFINAE (Substitution failure is not an error ) 



##### require  *c++20 特性*









#### auto



#### constexpr 

`constexpr`用于变量时本质上是`const`类型的加强, 它表明该变量不仅是常量 还是编译期可知的. 一个常见的使用场景是用来修饰一些**整数常量表达式**, 以表达数组大小,对齐修饰符等.

```cpp
#include <array>

constexpr int arraySize = 14;
std::array<int, arraySize> baseArray;
```



但是当`constexpr`用于函数时, 情况又有差别. 涉及到`constexpr`函数时，`constexpr`对象的使用情况就更有趣了。如果实参是编译期常量，这些函数将产出编译期常量；如果实参是运行时才能知道的值，它们就将产出运行时值。这里不做详细展开了.





