## 面向对象

##### 创建对象的两种方式

C++在创建对象的时候可以采用两种方式：（例如类名为Test）`Test test` 或者 `Test* pTest = new Test()`。

这两种方法都可以实例化一个对象，但是这两种方法有很大的区别，**对象内容所在的内存空间不同**，众所周知，内存的分配方式有三种：

1. **从静态存储区域分配。** 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2. **在栈上创建。** 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。
3. **从堆上分配的。** 程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。

我们可以得出**在不使用new创建对象时，对象的内存空间是在栈中的**，其**作用范围只是在函数内部**，函数执行完成后就会调用析构函数，删除该对象。

而**使用new创建对象是创建在堆中的**，必须要程序员手动的去管理该对象的内存空间。

new创建类对象，使用完后需使用delete删除，跟申请内存类似。所以，new有时候又不太适合，比如在频繁调用场合，使用局部new类对象就不是个好选择，使用全局类对象或一个经过初始化的全局类指针似乎更加高效。

:tired_face:

#### c++的权限管理和继承机制

> (1)需要被外界访问的成员直接设置为public
> (2)只能在当前类中访问的成员设置为private
> (3)只能在当前类和子类中访问的成员设置为protected。







## 其他使用特性

### 左值与右值

> **左值(lvalue, locator, value)** 表示一个 占据了内存中可识别位置*(一个地址，栈或堆)* 的对象。
>
> **右值**   使用排除法来定义 右值就是一个 *不* 表示内存中某个可识别位置的对象的表达式。存放在寄存器中的临时的值。

#### cpp 11之前

cpp 11之前， cpp的左值分类基本遵循c语言的分类





### 模板template





### 关键字

##### constexpr 

##### auto





### 引用的底层实现 int&



